#include "CCharacter.h"
#include "NxOgreConverter.h"
#include "ApeManager.h"

/*static*/ 
const std::string CCharacter::mFamilyID = "CCharacter";
const std::string CCharacter::mComponentID = "CCharacter";

NxControllerAction  CCharacter::onShapeHit(const NxControllerShapeHit& hit)
{
	if(1 && hit.shape)
	{
		NxCollisionGroup group = hit.shape->getGroup();
		if(group!=GROUP_COLLIDABLE_NON_PUSHABLE)
		{
			NxActor& actor = hit.shape->getActor();
			if(actor.isDynamic())
			{
				if ((mPts[mNbPts].x != hit.worldPos.x) || (mPts[mNbPts].y != hit.worldPos.y) || (mPts[mNbPts].z != hit.worldPos.z))
				{
					mPts[mNbPts++].x = hit.worldPos.x;
					mPts[mNbPts++].y = hit.worldPos.y;
					mPts[mNbPts++].z = hit.worldPos.z;
					if (mNbPts==MAX_NB_PTS)  mNbPts = 0;
				}

				// We only allow horizontal pushes. Vertical pushes when we stand on dynamic objects creates
				// useless stress on the solver. It would be possible to enable/disable vertical pushes on
				// particular objects, if the gameplay requires it.
				if(hit.dir.y==0.0f)
				{
					NxF32 coeff = actor.getMass() * hit.length * 10.0f;
					actor.addForceAtLocalPos(hit.dir*coeff, NxVec3(0,0,0), NX_IMPULSE);
					//						actor.addForceAtPos(hit.dir*coeff, hit.controller->getPosition(), NX_IMPULSE);
					//						actor.addForceAtPos(hit.dir*coeff, hit.worldPos, NX_IMPULSE);
				}
			}
		}
	}

	return NX_ACTION_NONE;
}

NxControllerAction  CCharacter::onControllerHit(const NxControllersHit& hit)
{
	return NX_ACTION_NONE;
}


void CCharacter::startJump(NxF32 v0)
{
	if(mJump)	return;
	mJumpTime = 0.0f;
	mV0	= v0;
	mJump = true;
}

void CCharacter::stopJump()
{
	if(!mJump)	return;
	mJump = false;
}

NxF32 CCharacter::getHeight(NxF32 elapsedTime)
{
	if(!mJump)	
		return 0.0f;
	mJumpTime += elapsedTime * 8.5;
	NxF32 h = G*mJumpTime*mJumpTime + mV0*mJumpTime;
	NxF32 height = (h - mDefaultGravity.y)*elapsedTime;
	return height;
}

//, UserAllocator* userAlloc, NxScene* scene,
CCharacter::CCharacter(OgreRender* ogre,Physics* physics,ObjectManager* objman,InputHandler* input, Ogre::String characterName,Ogre::String entityName, Ogre::Camera* cam,CameraView view) {

	mOgre = ogre;
	mPhysics = physics;
	mObjMan = objman;
	mInput = input;
	mSceneMgr = mOgre->getSceneManager();
	mMyAllocator = (UserAllocator*)mPhysics->getWorld()->getPhysXDriver()->getUserAllocator();
	mScene = mPhysics->getWorld()->getScenes()->get("Main")->getNxScene();

	//////////////////////////////////////////////////////////////////////////
	mSpeed = 60.0;
	mInitialRadius = 6.5f;
	mInitialHeight = 16.0f;
	mScale = 1.5;
	
	//mCameraOffset = Ogre::Vector3(0,4,0); //FPS
	
	mCurrentView = CAMERA_THIRD_PERSON_FREE;

	if(mCurrentView == CAMERA_THIRD_PERSON)
		mCameraOffset = Ogre::Vector3(0,4,4);
	else
		mCameraOffset = Ogre::Vector3(0,4,0);

	mTimestepMultiplier	= 1.0f;
	mSpeedMultiplier= 1.0f;
	mCharacterSpeed	= 0.1f;
	G = -49.8f;
	mDefaultGravity = NxVec3(0.0f, -49.8f, 0.0f);
	mStartPos = NxVec3(588.064,1900.998,988.782);
	
	mFilter.SetHistoryBufferLength(20);
	mFilter.SetWeightModifier(0.9f);
	mUseMouseFilter = true;
	mSensibility = 0.005f;

	Vector3 startPos = Vector3(0,0,0);
	mEntity = mSceneMgr->createEntity("asdasd","ninja.mesh"); //Ticket Collector.mesh
	
	//////////////////////////////////////////////////////////////////////////
	//Aim mode
	if(mCurrentView == CAMERA_THIRD_PERSON_AIM) {
		MainNode = mSceneMgr->getRootSceneNode()->createChildSceneNode("MainNode"); //,startPos
		MainNode->translate(startPos); // + Vector3(0, 50, 0)
		PlayerNode = MainNode->createChildSceneNode("PlayerNode"); //,startPos
		PlayerNode->attachObject(mEntity);
		PlayerNode->setScale(0.1,0.1,0.1);
		CameraNode = MainNode->createChildSceneNode("CameraNode");
		CameraPitchNode = CameraNode->createChildSceneNode("CameraPitchNode");
		mOgre->getCamera()->setPosition(MainNode->getPosition()); //startPos
		CameraPitchNode->attachObject (mOgre->getCamera());
		CameraNode->translate(Vector3(0, -startPos.y+50, 100));
	}	
	//////////////////////////////////////////////////////////////////////////
	if(mCurrentView == CAMERA_THIRD_PERSON_FREE)  {
		MainNode = mSceneMgr->getRootSceneNode()->createChildSceneNode("MainNode");
		//MainNode->translate(startPos); // + Vector3(0, 50, 0)
		PlayerNode = mSceneMgr->getRootSceneNode()->createChildSceneNode("PlayerNode");
		PlayerNode->attachObject(mEntity);
		PlayerNode->setScale(0.1,0.1,0.1);
		CameraNode = MainNode->createChildSceneNode("CameraNode");
		CameraPitchNode = CameraNode->createChildSceneNode("CameraPitchNode");
		mOgre->getCamera()->setPosition(startPos);
		CameraPitchNode->attachObject (mOgre->getCamera());
		CameraPitchNode->translate(Vector3(0, 0, 100));
	}
	mRotating = false;
	MainNode->setPosition(NxTools::convert(mStartPos));
	//////////////////////////////////////////////////////////////////////////

	//mAnimationState = mEntity->getAnimationState( "Idle1" );
	//mAnimationState = mEntity->getAnimationState( "Sneak" );
	//mAnimationState->setLoop( true );
	//mAnimationState->setEnabled( true ); 

	//Ticket Collector.mesh
	//Sneak
	//WalkLoop
	//WalkStart
	//WalkStop
	mAnimationState = mEntity->getAnimationState("Idle1"); //WalkLoop Sneak
	mAnimationState->setTimePosition(0);
	mAnimationState->setLoop(true);
	mAnimationState->setEnabled(true);

	//mAnimationState->setTimePosition(0);
	//////////////////////////////////////////////////////////////////////////

	//gScene = get scene here

	Ogre::Camera* mCamera;
	Ogre::SceneNode* mNode;
	
	//mCurrentView = view;

	/*
	if(!cam) {
		if(!mEntity) {
			exit(1);
		} else {
			mCurrentView = CAMERA_THIRD_PERSON;
		}
	}
	else {
		mCamera = cam;
		if(!mEntity) {
			mCurrentView = CAMERA_FIRST_PERSON;
		}
	}
	*/
	
	//Ogre::Entity *mEntity;
	//mEntity = mOgre->getSceneManager()->createEntity(characterName, entityName);
	
	

	//if(mCamera) {
		//Ogre::String name = characterName + StringConverter::toString(GameObjectManager::getSingleton()->getNextCompIndex());
		//mCameraNode = mSceneMgr->getRootSceneNode()->createChildSceneNode(name);
		//mCameraNode->attachObject(mCamera);
	//}

	//gDefaultGravity = NxVec3(0.0f, -0.3f, 0.0f);
	

	mPause = false;
	//G = -98.1f;//-50.0f;
	
	//gControlledCharacterIndex = 0;
	mApplyGravity = true;
	//gDrawSkinWidth	= false;
	mFreeMove		= false;
	mMotion			= false;	
	mUseMouseFilter	= true;
	mRigidLink		= false;
	mFixedStep		= false;
	
	
	mManager = NULL;
	SKINWIDTH = 0.2f;
	
	mNbPts = 0;
	mJump =  false;
	mV0 = 0.0f;
	mJumpTime = 0.0f;
	mDirection_Locked = false;
	
	CreateControllerManager(mMyAllocator); //getUserAllocator()
	InitCharacterControllers(mStartPos, 1, *mScene);

	mIsActive = false;

}

void CCharacter::setCamera(Ogre::Camera* cam) {
	//gMotion = true;
	mCamera = cam;

}
void CCharacter::move(Direction _direction, Ogre::Quaternion orientation) {

	mMotion = true;
/*
	mNextMovement = Ogre::Vector3::ZERO;
	mDirection = orientation;

	switch(_direction) {
		 case MOVE_FORWARD:
			 mNextMovement.z = -1 * mSpeed;
			 //mNextMovement.z = mSpeed;
			 break;

		 case MOVE_BACKWARD:
			 //mNextMovement.z = -1 * mSpeed;
			 mNextMovement.z = mSpeed;
			 break;

		 case MOVE_LEFT:
			mNextMovement.x = -1 * mSpeed;
			 break;
		 case MOVE_RIGHT:
			 mNextMovement.x = mSpeed;
			 break;
			 //M@gg! added
		 case MOVE_UP:
			 //mNextMovement.y = mSpeed;
			 break;
		 case MOVE_DOWN:
			 //mNextMovement.y = -1 * mSpeed;
			 break;
		 case JUMP:
			 startJump(550.0f);
			 break;
	}

	*/
}

float getElapsedTime()
{
	static LARGE_INTEGER previousTime;
	static LARGE_INTEGER freq;
	static bool init = false;
	if(!init){
		QueryPerformanceFrequency(&freq);
		QueryPerformanceCounter(&previousTime);
		init=true;
	}
	LARGE_INTEGER currentTime;
	QueryPerformanceCounter(&currentTime);
	unsigned long long elapsedTime = currentTime.QuadPart - previousTime.QuadPart;
	previousTime = currentTime;
	return (float)(elapsedTime)/(freq.QuadPart);
}

void CCharacter::simulate(float time) {

	if(!mScene)	
		return;

	if(!mCamera)
		return;

	//if(physics_config.isSimulation || !physics_config.isInitialized)
	//	return;

	//NxF32 elapsedTime = getElapsedTime(); //time
	NxF32 elapsedTime = mOgre->getTimeSinceLastFrame();
	elapsedTime *= mTimestepMultiplier;
	if(elapsedTime <= 0)
		elapsedTime = 0;

	if(!mPause)	
	{
		NxVec3 disp = mDefaultGravity;
		if(!mApplyGravity)	disp.zero();

		if(mMotion)
		{
			Ogre::Vector3 tmpPos = (mDirection * mNextMovement);
			NxVec3 horizontalDisp = NxTools::convert(tmpPos);
			horizontalDisp.y = 0.0f;
			horizontalDisp.normalize();

			disp += horizontalDisp * mSpeed * mSpeedMultiplier; //gCharacterSpeed
		}
		//disp = disp * elapsedTime;
		//NxF32 heightDelta = getHeight(elapsedTime);
		//if(heightDelta!=0.0f)
		//	disp.y+=heightDelta;
		
		//NxU32 collisionFlags;
		//NxVec3 d = dispVector*elapsedTime;
		//if(heightDelta!=0.0f)
		//	d.y+=heightDelta;
		
		//NxVec3 v = NxVec3(GetCharacterPos().x,GetCharacterPos().y,GetCharacterPos().z);
		//MainNode->setPosition(MainNode->getPosition().x,MainNode->getPosition().y+50,MainNode->getPosition().z);		
		//MainNode->translate(NxTools::convert(disp) );// setPosition(NxTools::convert(v));

		NxU32 collisionFlags = MoveCharacter(*mScene, disp, elapsedTime, 1,getHeight(elapsedTime)); //elapsedTime
		if(collisionFlags & NXCC_COLLISION_DOWN) {
			//if(!mJump) {
				stopJump();
				//disp.y = 0;
			//}

		}
		//NxVec3 v = NxVec3(GetCharacterPos().x,GetCharacterPos().y,GetCharacterPos().z);
		//Vector3 oPos = NxTools::convert(v);
		//MainNode->setPosition(oPos.x,oPos.y,oPos.z);
		//MainNode->setPosition(MainNode->getPosition().x,MainNode->getPosition().y+50,MainNode->getPosition().z);

		//mCamera->move(NxTools::convert(disp));
		if(mCurrentView == CAMERA_FIRST_PERSON) {
			//Ogre::Vector3 newPos = Ogre::Vector3(v.x,v.y,v.z) + mCameraOffset;
			//mCamera->setPosition(newPos);
			//mOgre->getCamera()->setPosition(newPos);
		}
		else {
			//Ogre::Vector3 newPos = Ogre::Vector3(v.x,v.y,v.z) + mCameraOffset;
			//mOgre->getCamera()->setPosition(newPos);
			//mEntityNode->setPosition(Ogre::Vector3(v.x,v.y,v.z));
		}

		//mMotion = false;
		UpdateControllers();

	}

}


/*
void Character::jump() {


}
*/

void CCharacter::CreateControllerManager(NxUserAllocator* a)
{
	mManager = NxCreateControllerManager(a);
}

void CCharacter::ReleaseControllerManager()
{
	NxReleaseControllerManager(mManager);
}

void CCharacter::UpdateControllers()
{
	mManager->updateControllers();
}

NxController* CCharacter::InitCharacterControllers(const NxVec3 startPos, NxReal scale, NxScene& scene)
{
	NxCapsuleControllerDesc desc;
	NxVec3 tmp			= startPos;
	desc.position.x		= tmp.x;
	desc.position.y		= tmp.y;
	desc.position.z		= tmp.z;
	desc.radius			= mInitialRadius * mScale;
	desc.height			= mInitialHeight * mScale;
	desc.upDirection	= NX_Y;
	//		desc.slopeLimit		= cosf(NxMath::degToRad(45.0f));
	desc.slopeLimit		= 0;
	desc.skinWidth		= SKINWIDTH;
	desc.stepOffset		= 0.5;
	desc.stepOffset		= mInitialRadius * 0.5 * mScale;
	//	desc.stepOffset	= 0.01f;
	//		desc.stepOffset		= 0;	// Fixes some issues
	//		desc.stepOffset		= 10;
	desc.callback		= this; //&gControllerHitReport;

	//gManager->createController(&scene, desc);

	NxController* c = mManager->createController(&scene, desc);
	c->setCollision(true);
	NxActor* mActor = c->getActor(); 
	mActor->setGroup(1);			

	return mManager->getController(0);
}

void CCharacter::ReleaseCharacterControllers(NxScene& scene)
{
	mManager->purgeControllers();
}

NxU32 CCharacter::MoveCharacter(NxScene& scene, const NxVec3& dispVector, NxF32 elapsedTime, NxU32 collisionGroups, NxF32 heightDelta)
{
	mNbPts = 0;

	//	NxF32 sharpness = 0.1f;
	NxF32 sharpness = 1.0f;

	NxU32 collisionFlags;
	//NxVec3 d = dispVector;
	NxVec3 d = dispVector*elapsedTime;
	if(heightDelta!=0.0f)
		d.y+=heightDelta;

	NxController* c = mManager->getController(0);
	c->move(d, collisionGroups, 0.000001f, collisionFlags, sharpness);
	NxVec3 v = NxVec3(GetCharacterPos().x,GetCharacterPos().y,GetCharacterPos().z);
	
	

	MainNode->setPosition(NxTools::convert(v));

	v.y = v.y - 20;

	PlayerNode->setPosition(NxTools::convert(v));

	//c->get
	return collisionFlags;
}

const NxExtendedVec3& CCharacter::GetCharacterPos() //NxU32 characterIndex
{
	return mManager->getController(0)->getFilteredPosition();
}

NxActor* CCharacter::GetCharacterActor(NxU32 characterIndex)
{
	return mManager->getController(characterIndex)->getActor();
}

bool CCharacter::ResetCharacterPos(NxU32 index, const NxVec3& pos)
{
	return mManager->getController(index)->setPosition(NxExtendedVec3(pos.x, pos.y, pos.z));
}

bool CCharacter::UpdateCharacterExtents(NxU32 index, bool& increase)
{
	if(index&1)
	{
		NxBoxController* c = static_cast<NxBoxController*>(mManager->getController(index));
		NxVec3 extents = c->getExtents();
		NxF32 inc = 1.0f;
		NxExtendedVec3 pos = GetCharacterPos();
		if (increase)
		{
			extents.y += inc;
			pos.y += inc;
		} 
		else 
		{ 
			extents.y -= inc;
			pos.y -= inc;
		}

		if(1)
		{
			NxBounds3 worldBounds;
			worldBounds.setCenterExtents(NxVec3(pos.x, pos.y, pos.z), extents);
			c->setCollision(false);	// Avoid checking overlap with ourself
			bool Status = mScene->checkOverlapAABB(worldBounds);
			c->setCollision(true);
			if(Status)
			{
				printf("Can not resize box!\n");
				return false;
			}
		}

		increase = !increase;	// Increase or decrease height each time we're called

		// WARNING: the SDK currently doesn't check for collisions when changing extents, so if you're close
		// to a wall you might end up penetrating it. In some cases you might also fall through the level.
		// A more advanced implementation will take care of that later.
		c->setPosition(pos);
		return c->setExtents(extents);
	}
	else
	{
		NxCapsuleController* c = static_cast<NxCapsuleController*>(mManager->getController(index));
		NxF32 height = c->getHeight();
		NxF32 radius = c->getRadius();
		NxF32 inc = 1.0f;
		NxExtendedVec3 pos = GetCharacterPos();
		if (increase)
		{
			height += inc;
			pos.y += inc*0.5f;
		} 
		else 
		{ 
			height -= inc;
			pos.y -= inc*0.5f;
		}

		if(1)
		{
			NxCapsule worldCapsule;
			worldCapsule.p0.x = worldCapsule.p1.x = pos.x;
			worldCapsule.p0.y = worldCapsule.p1.y = pos.y;
			worldCapsule.p0.z = worldCapsule.p1.z = pos.z;
			worldCapsule.p0.y -= height*0.5f;
			worldCapsule.p1.y += height*0.5f;
			worldCapsule.radius = radius;
			c->setCollision(false);	// Avoid checking overlap with ourself
			bool Status = mScene->checkOverlapCapsule(worldCapsule);
			c->setCollision(true);
			if(Status)
			{
				printf("Can not resize capsule!\n");
				return false;
			}
		}

		increase = !increase;	// Increase or decrease height each time we're called

		// WARNING: the SDK currently doesn't check for collisions when changing height, so if you're close
		// to a wall you might end up penetrating it. In some cases you might also fall through the level.
		// A more advanced implementation will take care of that later.
		c->setPosition(NxExtendedVec3(pos.x, pos.y, pos.z));
		return c->setHeight(height);
	}
}

void CCharacter::update() {
	float time = mOgre->getTimeSinceLastFrame();

	getUserInput();

	simulate(time);


}
void CCharacter::setup() {
	
	

}

void CCharacter::getUserInput() {

	updateCharacter();

	if(ApeManager::getSingleton().isEditorMode()) {
		
		//mCamera->getOrientation();
		//move()
		//Ogre::Vector3 move(0, 0, 0);
		//mInput->capture();

		static float pitch = 0, yaw = 0;

		// get the current mouse state
		const OIS::MouseState &ms = mInput->getMouseStat();

		//if(ms.Y.rel != 0 || ms.X.rel != 0)
		//	mMotion = true;

		// fix pitch and yaw
		pitch += -ms.Y.rel * 0.1;
		yaw += -ms.X.rel * 0.1;

		if (pitch < -90) pitch = -90;
		if (pitch >  90) pitch =  90;

		Camera* cam = mOgre->getCamera();

		cam->setOrientation(Ogre::Quaternion::IDENTITY);
		cam->yaw(Ogre::Degree(yaw));
		cam->pitch(Ogre::Degree(pitch));

		//Camera* cam = mOgre->getCamera();
		if (mInput->getKeyboard()->isKeyDown(OIS::KC_W)) // getKeyboard()->isKeyDown(OIS::KC_W)
			move(Direction::MOVE_FORWARD,cam->getOrientation());
		if (mInput->getKeyboard()->isKeyDown(OIS::KC_S))
			move(Direction::MOVE_BACKWARD,cam->getOrientation());
		if (mInput->getKeyboard()->isKeyDown(OIS::KC_A))
			move(Direction::MOVE_LEFT,cam->getOrientation());
		if (mInput->getKeyboard()->isKeyDown(OIS::KC_D))
			move(Direction::MOVE_RIGHT,cam->getOrientation());
		if (mInput->getKeyboard()->isKeyDown(OIS::KC_SPACE))
			startJump(200);
		//if (mInput->getKeyboard()->isKeyDown(OIS::KC_Q))
			//this->move(Direction::MOVE,mOgre->getCamera()->getOrientation());
		//if (mInput->getKeyboard()->isKeyDown(OIS::KC_E))
			//this->move(Direction::MOVE_FORWARD,mOgre->getCamera()->getOrientation());
		


	}
}

void CCharacter::updateCharacter() {
	
	float time = mOgre->getTimeSinceLastFrame();

	Ogre::Vector3 Direction = MainNode->getOrientation()*Ogre::Vector3::NEGATIVE_UNIT_Z;
	Direction.normalise();
	Ogre::Vector3 Movement;
	Movement = Vector3(0,0,0);
	mNextMovement = Vector3(0,0,0);
	if(mInput->getKeyboard()->isKeyDown(OIS::KC_W))
	{
		mNextMovement.z = -1 * mSpeed;
	}
	if(mInput->getKeyboard()->isKeyDown(OIS::KC_S))
	{
		mNextMovement.z = mSpeed;
	}
	if(mInput->getKeyboard()->isKeyDown(OIS::KC_D))
	{
		mNextMovement.x = mSpeed;
	}
	if(mInput->getKeyboard()->isKeyDown(OIS::KC_A))
	{
		mNextMovement.x = -1 * mSpeed;
	}
	if(mInput->getKeyboard()->isKeyDown(OIS::KC_SPACE))
	{
		startJump(250);
	}
	if(mNextMovement.x == 0 && mNextMovement.z == 0)
	{
		mMotion = false;
	}
	else
	{
		mMotion = true;

		if(!mRotating) {
			mRotating = true;
			mOrientSrc = PlayerNode->getOrientation();

			Vector3 localY = PlayerNode->getOrientation() * Vector3::NEGATIVE_UNIT_Z;
			Quaternion quat = localY.getRotationTo(MainNode->getOrientation() * Vector3::NEGATIVE_UNIT_Z);                        
			mOrientDest = quat;

			mDestYaw = Degree(quat.getYaw());
			mYawInc = (mDestYaw < Degree(0)) ? Degree(-12.0) : Degree(12.0) ;
			mYaw = Degree(0);

			mAnimationState = mEntity->getAnimationState( "Walk" );
			mAnimationState->setLoop(true);
			mAnimationState->setEnabled(true);
		}

		if(mCurrentView == CAMERA_THIRD_PERSON_FREE) {
			if(mRotating)
			{
				//This allow us to have a free view camera, 
				//but when you move the character it will turn facing that 
				//direction (mTurnReactionSpeed)
				mYaw += Degree(mYawInc);
				if( (mYawInc < Degree(0)) ? (mYaw < mDestYaw) : (mYaw > mDestYaw) )
					mRotating = false;
				else
					PlayerNode->yaw(mYawInc);
			} 
			
		}
	}
	
	Vector3 dist = PlayerNode->getOrientation() * Vector3::NEGATIVE_UNIT_Z;
	Quaternion quat = dist.getRotationTo(MainNode->getOrientation() * Vector3::NEGATIVE_UNIT_Z); 
	mDestYaw = quat.getYaw();
	mOgre->getDebugText()->addText("yaw =" + Ogre::StringConverter::toString(mDestYaw));
	//mOgre->getDebugText()->addText("yaw =" + Ogre::StringConverter::toString(quat.getYaw()));
	
	const OIS::MouseState &ms = mInput->getMouseStat();

	//NxF32 x,y;
	//x = NxF32(ms.X.abs);
	//y = NxF32(ms.Y.abs);
	
	//if(mUseMouseFilter)	
	//	mFilter.Apply(x, y);

	Degree mRotX = Degree(-ms.X.rel * 0.13);
	Degree mRotY = Degree(-ms.Y.rel * 0.13);

	MainNode->yaw(mRotX);
	CameraNode->pitch(mRotY);

	mDirection = MainNode->getOrientation();

	Degree viewPitch = Degree(CameraNode->getOrientation().getPitch());
	if (viewPitch < Degree(-90)) {
		CameraNode->setOrientation(Quaternion::IDENTITY);
		CameraNode->pitch(Degree(-90));
	}
	if (viewPitch >  Degree(90)) {
		CameraNode->setOrientation(Quaternion::IDENTITY);
		CameraNode->pitch(Degree(90));
	}

	if(mCurrentView == CAMERA_THIRD_PERSON_AIM) {
		//PlayerNode->setPosition(MainNode->getPosition());
		PlayerNode->yaw(mRotX);
	}

	mAnimationState->addTime(time * 1.5);
}