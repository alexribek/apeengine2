#include "CCharacter.h"
#include "NxOgreConverter.h"
#include "ApeManager.h"

/*static*/ 
const std::string CCharacter::mFamilyID = "CCharacter";
const std::string CCharacter::mComponentID = "CCharacter";

NxControllerAction  CCharacter::onShapeHit(const NxControllerShapeHit& hit)
{
	if(1 && hit.shape)
	{
		NxCollisionGroup group = hit.shape->getGroup();
		if(group!=GROUP_COLLIDABLE_NON_PUSHABLE)
		{
			NxActor& actor = hit.shape->getActor();
			if(actor.isDynamic())
			{
				if ((mPts[mNbPts].x != hit.worldPos.x) || (mPts[mNbPts].y != hit.worldPos.y) || (mPts[mNbPts].z != hit.worldPos.z))
				{
					mPts[mNbPts++].x = hit.worldPos.x;
					mPts[mNbPts++].y = hit.worldPos.y;
					mPts[mNbPts++].z = hit.worldPos.z;
					if (mNbPts==MAX_NB_PTS)  mNbPts = 0;
				}

				// We only allow horizontal pushes. Vertical pushes when we stand on dynamic objects creates
				// useless stress on the solver. It would be possible to enable/disable vertical pushes on
				// particular objects, if the gameplay requires it.
				if(hit.dir.y==0.0f)
				{
					NxF32 coeff = actor.getMass() * hit.length * 10.0f;
					actor.addForceAtLocalPos(hit.dir*coeff, NxVec3(0,0,0), NX_IMPULSE);
					//						actor.addForceAtPos(hit.dir*coeff, hit.controller->getPosition(), NX_IMPULSE);
					//						actor.addForceAtPos(hit.dir*coeff, hit.worldPos, NX_IMPULSE);
				}
			}
		}
	}

	return NX_ACTION_NONE;
}

NxControllerAction  CCharacter::onControllerHit(const NxControllersHit& hit)
{
	return NX_ACTION_NONE;
}


void CCharacter::startJump(NxF32 v0)
{
	if(mJump)	return;
	mJumpTime = 0.0f;
	mV0	= v0;
	mJump = true;
}

void CCharacter::stopJump()
{
	if(!mJump)	return;
	mJump = false;
}

NxF32 CCharacter::getHeight(NxF32 elapsedTime)
{
	if(!mJump)	
		return 0.0f;
	mJumpTime += elapsedTime * 8.5;
	NxF32 h = G*mJumpTime*mJumpTime + mV0*mJumpTime;
	NxF32 height = (h - mDefaultGravity.y)*elapsedTime;
	return height;
}

class myRaycastQueryReport : public NxSceneQueryReport
{
	virtual	NxQueryReportResult	onBooleanQuery(void* userData, bool result){ return NX_SQR_CONTINUE; };
	virtual	NxQueryReportResult	onShapeQuery(void* userData, NxU32 nbHits, NxShape** hits){ return NX_SQR_CONTINUE; };
	virtual	NxQueryReportResult	onSweepQuery(void* userData, NxU32 nbHits, NxSweepQueryHit* hits){ return NX_SQR_CONTINUE; };

	virtual	NxQueryReportResult	onRaycastQuery(void* userData, NxU32 nbHits, const NxRaycastHit* hits)
	{
		unsigned int i = (unsigned int)userData;
		if (nbHits > 0) {
		//	gHits[i] = hits[0];
		} else {
		//	gHits[i].shape = NULL;
		}
		return NX_SQR_CONTINUE;
	}
}gQueryReport;

//, UserAllocator* userAlloc, NxScene* scene,
CCharacter::CCharacter(OgreRender* ogre,Physics* physics,ObjectManager* objman,InputHandler* input, Ogre::String characterName,Ogre::String entityName, Ogre::Camera* cam,CameraView view) {

	mOgre = ogre;
	mPhysics = physics;
	mObjMan = objman;
	mInput = input;
	mSceneMgr = mOgre->getSceneManager();
	mMyAllocator = (UserAllocator*)mPhysics->getWorld()->getPhysXDriver()->getUserAllocator();
	mScene = mPhysics->getWorld()->getScenes()->get("Main")->getNxScene();

	//////////////////////////////////////////////////////////////////////////
	mSpeed = 100.0;
	mInitialRadius = 6.5f;
	mInitialHeight = 16.0f;
	mScale = 1.5;
	
	mAccelFactor = 1.0;
	mVel = 0.1;
	mMoveState = ST_IDLE;
	mZoom = 40;
	//mCameraOffset = Ogre::Vector3(0,4,0); //FPS
	
	mCurrentView = CAMERA_THIRD_PERSON_FREE;

	//if(mCurrentView == CAMERA_THIRD_PERSON)
	//	mCameraOffset = Ogre::Vector3(0,4,4);
	//else
	//	mCameraOffset = Ogre::Vector3(0,4,0);
	mNodeOffset = Ogre::Vector3(0,-22,0);

	mTimestepMultiplier	= 1.0f;
	mSpeedMultiplier= 1.0f;
	mCharacterSpeed	= 0.1f;
	G = -49.8f;
	mDefaultGravity = NxVec3(0.0f, -49.8f, 0.0f);
	mStartPos = NxVec3(588.064,900.998,988.782);
	
	mFilter.SetHistoryBufferLength(20); //20
	mFilter.SetWeightModifier(0.9f); //0.9f
	
	mTestFilter.SetHistoryBufferLength(20);
	mTestFilter.SetWeightModifier(0.9f);

	mZoomFilter.SetHistoryBufferLength(20);
	mZoomFilter.SetWeightModifier(0.9f);

	mCamFilter.SetHistoryBufferLength(40);
	mCamFilter.SetWeightModifier(1.9f);

	mUseMouseFilter = true;
	mSensibility = 0.005f;
	mMouseSpeed = 0.10;
	
	
	mSceneQueryObject = NULL;
	NxSceneQueryDesc sceneQueryDesc;
	sceneQueryDesc.report = &gQueryReport;
	mSceneQueryObject = mScene->createSceneQuery(sceneQueryDesc);


	Vector3 startPos = Vector3(0,0,0);
	mEntity = mSceneMgr->createEntity("asdasd","ninja.mesh"); //Ticket Collector.mesh
	
	//////////////////////////////////////////////////////////////////////////
	//Aim mode
	if(mCurrentView == CAMERA_THIRD_PERSON_AIM) {
		mMainNode = mSceneMgr->getRootSceneNode()->createChildSceneNode("MainNode"); //,startPos
		mMainNode->translate(startPos); // + Vector3(0, 50, 0)
		mPlayerNode = mMainNode->createChildSceneNode("PlayerNode"); //,startPos
		mPlayerNode->attachObject(mEntity);
		mPlayerNode->setScale(0.1,0.1,0.1);
		mCameraNode = mMainNode->createChildSceneNode("CameraNode");
		mCameraPitchNode = mCameraNode->createChildSceneNode("CameraPitchNode");
		mOgre->getCamera()->setPosition(mMainNode->getPosition()); //startPos
		mCameraPitchNode->attachObject (mOgre->getCamera());
		mCameraNode->translate(Vector3(0, -startPos.y+50, 100));
	}	
	//////////////////////////////////////////////////////////////////////////
	if(mCurrentView == CAMERA_THIRD_PERSON_FREE)  {
		mMainNode = mSceneMgr->getRootSceneNode()->createChildSceneNode("MainNode");
		//MainNode->translate(startPos); // + Vector3(0, 50, 0)
		mPlayerNode = mSceneMgr->getRootSceneNode()->createChildSceneNode("PlayerNode");
		mPlayerNode->attachObject(mEntity);
		mPlayerNode->setScale(0.1,0.1,0.1);
		mCameraNode = mMainNode->createChildSceneNode("CameraNode");
		mCameraPitchNode = mCameraNode->createChildSceneNode("CameraPitchNode");
		mOgre->getCamera()->setPosition(0,0,0);
		mCameraPitchNode->attachObject (mOgre->getCamera());
		mCameraPitchNode->translate(Vector3(0, 0, 100));
		
		//mOgre->getCamera()->move(Vector3(0,0,100));
	}
	mRotating = false;
	mMainNode->setPosition(NxTools::convert(mStartPos));
	//////////////////////////////////////////////////////////////////////////

	//mAnimationState = mEntity->getAnimationState( "Idle1" );
	//mAnimationState = mEntity->getAnimationState( "Sneak" );
	//mAnimationState->setLoop( true );
	//mAnimationState->setEnabled( true ); 

	//Ticket Collector.mesh
	//Sneak
	//WalkLoop
	//WalkStart
	//WalkStop
	mAnimationState = mEntity->getAnimationState("Idle1"); //WalkLoop Sneak
	mAnimationState->setTimePosition(0);
	mAnimationState->setLoop(true);
	mAnimationState->setEnabled(true);

	//mAnimationState->setTimePosition(0);
	//////////////////////////////////////////////////////////////////////////

	Ogre::Camera* mCamera;
	Ogre::SceneNode* mNode;
	
	mPause = false;
	mApplyGravity = true;
	mFreeMove		= false;
	mMotion			= false;	
	mUseMouseFilter	= true;
	mRigidLink		= false;
	mFixedStep		= false;
	mManager = NULL;
	mSkinwidth = 0.2f;
	
	mNbPts = 0;
	mJump =  false;
	mV0 = 0.0f;
	mJumpTime = 0.0f;
	mDirection_Locked = false;
	mJumpStrength = 160;
	mTurnReactionTime = 5.0;

	createControllerManager(mMyAllocator); //getUserAllocator()
	initCharacterControllers(mStartPos, 1, *mScene);

	mIsActive = false;

}

void CCharacter::setCamera(Ogre::Camera* cam) {
	mCamera = cam;
}

float getElapsedTime()
{
	static LARGE_INTEGER previousTime;
	static LARGE_INTEGER freq;
	static bool init = false;
	if(!init){
		QueryPerformanceFrequency(&freq);
		QueryPerformanceCounter(&previousTime);
		init=true;
	}
	LARGE_INTEGER currentTime;
	QueryPerformanceCounter(&currentTime);
	unsigned long long elapsedTime = currentTime.QuadPart - previousTime.QuadPart;
	previousTime = currentTime;
	return (float)(elapsedTime)/(freq.QuadPart);
}

void CCharacter::createControllerManager(NxUserAllocator* a)
{
	mManager = NxCreateControllerManager(a);
}

void CCharacter::releaseControllerManager()
{
	NxReleaseControllerManager(mManager);
}

void CCharacter::updateControllers()
{
	mManager->updateControllers();
}

NxController* CCharacter::initCharacterControllers(const NxVec3 startPos, NxReal scale, NxScene& scene)
{
	NxCapsuleControllerDesc desc;
	NxVec3 tmp			= startPos;
	desc.position.x		= tmp.x;
	desc.position.y		= tmp.y;
	desc.position.z		= tmp.z;
	desc.radius			= mInitialRadius * mScale;
	desc.height			= mInitialHeight * mScale;
	desc.upDirection	= NX_Y;
	//		desc.slopeLimit		= cosf(NxMath::degToRad(45.0f));
	desc.slopeLimit		= 0;
	desc.skinWidth		= mSkinwidth;
	desc.stepOffset		= 0.5;
	desc.stepOffset		= mInitialRadius * 0.5 * mScale;
	//	desc.stepOffset	= 0.01f;
	//		desc.stepOffset		= 0;	// Fixes some issues
	//		desc.stepOffset		= 10;
	desc.callback		= this; //&gControllerHitReport;

	//gManager->createController(&scene, desc);

	NxController* c = mManager->createController(&scene, desc);
	c->setCollision(true);
	NxActor* mActor = c->getActor(); 
	mActor->setGroup(1);			

	return mManager->getController(0);
}

void CCharacter::releaseCharacterControllers(NxScene& scene)
{
	mManager->purgeControllers();
}

const NxVec3& CCharacter::getCharacterPos() //NxU32 characterIndex
{
	NxExtendedVec3 pos = mManager->getController(0)->getFilteredPosition();
	return NxVec3(pos.x,pos.y,pos.z);
}

NxActor* CCharacter::getCharacterActor(NxU32 characterIndex)
{
	return mManager->getController(characterIndex)->getActor();
}

bool CCharacter::resetCharacterPos(NxU32 index, const NxVec3& pos)
{
	return mManager->getController(index)->setPosition(NxExtendedVec3(pos.x, pos.y, pos.z));
}

bool CCharacter::updateCharacterExtents(NxU32 index, bool& increase)
{
	if(index&1)
	{
		NxBoxController* c = static_cast<NxBoxController*>(mManager->getController(index));
		NxVec3 extents = c->getExtents();
		NxF32 inc = 1.0f;
		NxVec3 pos = getCharacterPos();
		if (increase)
		{
			extents.y += inc;
			pos.y += inc;
		} 
		else 
		{ 
			extents.y -= inc;
			pos.y -= inc;
		}

		if(1)
		{
			NxBounds3 worldBounds;
			worldBounds.setCenterExtents(NxVec3(pos.x, pos.y, pos.z), extents);
			c->setCollision(false);	// Avoid checking overlap with ourself
			bool Status = mScene->checkOverlapAABB(worldBounds);
			c->setCollision(true);
			if(Status)
			{
				printf("Can not resize box!\n");
				return false;
			}
		}

		increase = !increase;	// Increase or decrease height each time we're called

		// WARNING: the SDK currently doesn't check for collisions when changing extents, so if you're close
		// to a wall you might end up penetrating it. In some cases you might also fall through the level.
		// A more advanced implementation will take care of that later.
		c->setPosition(NxExtendedVec3(pos.x,pos.y,pos.z));
		return c->setExtents(extents);
	}
	else
	{
		NxCapsuleController* c = static_cast<NxCapsuleController*>(mManager->getController(index));
		NxF32 height = c->getHeight();
		NxF32 radius = c->getRadius();
		NxF32 inc = 1.0f;
		NxVec3 pos = getCharacterPos();
		if (increase)
		{
			height += inc;
			pos.y += inc*0.5f;
		} 
		else 
		{ 
			height -= inc;
			pos.y -= inc*0.5f;
		}

		if(1)
		{
			NxCapsule worldCapsule;
			worldCapsule.p0.x = worldCapsule.p1.x = pos.x;
			worldCapsule.p0.y = worldCapsule.p1.y = pos.y;
			worldCapsule.p0.z = worldCapsule.p1.z = pos.z;
			worldCapsule.p0.y -= height*0.5f;
			worldCapsule.p1.y += height*0.5f;
			worldCapsule.radius = radius;
			c->setCollision(false);	// Avoid checking overlap with ourself
			bool Status = mScene->checkOverlapCapsule(worldCapsule);
			c->setCollision(true);
			if(Status)
			{
				printf("Can not resize capsule!\n");
				return false;
			}
		}

		increase = !increase;	// Increase or decrease height each time we're called

		// WARNING: the SDK currently doesn't check for collisions when changing height, so if you're close
		// to a wall you might end up penetrating it. In some cases you might also fall through the level.
		// A more advanced implementation will take care of that later.
		c->setPosition(NxExtendedVec3(pos.x, pos.y, pos.z));
		return c->setHeight(height);
	}
}


void CCharacter::update() {

	updateCharacter();

}
void CCharacter::setup() {
	
	

}
NxF32 CCharacter::cameraHit(NxVec3 cpos, NxVec3 dir)
{
	
	NxShape* characterShape = getCharacterActor(0)->getShapes()[0];

	//NxExtendedVec3 cpos = getCharacterPos();

	NxRay worldRay;
	//588.064,900.998,988.782
	//worldRay.orig.x	= cpos.x; 
	//worldRay.orig.y	= cpos.y;
	//worldRay.orig.z	= cpos.z;
	//worldRay.dir	= dir;

	//worldRay.orig	= NxVec3(588.064,900.998,988.782);
	worldRay.orig = cpos;

	//worldRay.dir	= NxVec3(0.0f,-1.0f,0.0f);
	//dir.normalize();
	worldRay.dir	= dir;

	NxRaycastHit hit;
	characterShape->setFlag(NX_SF_DISABLE_RAYCASTING, true);
	NxShape* shape = mScene->raycastClosestShape(worldRay, NX_ALL_SHAPES, hit);
	characterShape->setFlag(NX_SF_DISABLE_RAYCASTING, false);

	if(!mPause)	
		mWorldRay = worldRay;

	return shape ? hit.distance : 0; //NX_MAX_F32


	/*	

	NxRay worldRay;
	//worldRay.orig = NxVec3(cpos.x,cpos.y,cpos.z);
	worldRay.orig = NxVec3(588.064,900.998,988.782);
	//worldRay.orig.z += offset;

	worldRay.dir = dir;

	NxRaycastHit hit;
	NxShape* characterShape = getCharacterActor(0)->getShapes()[0];
	characterShape->setFlag(NX_SF_DISABLE_RAYCASTING, true);
	
	NxShape* shape = mSceneQueryObject->raycastClosestShape(worldRay, NX_ALL_SHAPES, hit, 0xffffffff, NX_MAX_F32, 0xffffffff, NULL, NULL);
	
	if(!mPause)	
		mWorldRay = worldRay;

	characterShape->setFlag(NX_SF_DISABLE_RAYCASTING, false);
	
	mSceneQueryObject->execute();
	mSceneQueryObject->finish(true);

	if(shape)
		return (hit.distance);
*/
}

NxVec3 CCharacter::cameraHitPos(NxVec3 cpos, NxVec3 dir)
{

	NxShape* characterShape = getCharacterActor(0)->getShapes()[0];

	//NxExtendedVec3 cpos = getCharacterPos();

	NxRay worldRay;
	//588.064,900.998,988.782
	//worldRay.orig.x	= cpos.x; 
	//worldRay.orig.y	= cpos.y;
	//worldRay.orig.z	= cpos.z;
	//worldRay.dir	= dir;

	//worldRay.orig	= NxVec3(588.064,900.998,988.782);
	worldRay.orig = cpos;

	//worldRay.dir	= NxVec3(0.0f,-1.0f,0.0f);
	//dir.normalize();
	worldRay.dir	= dir;

	NxRaycastHit hit;
	characterShape->setFlag(NX_SF_DISABLE_RAYCASTING, true);
	NxShape* shape = mScene->raycastClosestShape(worldRay, NX_ALL_SHAPES, hit);
	characterShape->setFlag(NX_SF_DISABLE_RAYCASTING, false);

	if(!mPause)	
		mWorldRay = worldRay;

	return shape ? hit.worldImpact : NxVec3(0,0,0); //NX_MAX_F32
}

void CCharacter::updateCharacter() {
	
	float time = mOgre->getTimeSinceLastFrame();

	Ogre::Vector3 Direction = mMainNode->getOrientation()*Ogre::Vector3::NEGATIVE_UNIT_Z;
	Direction.normalise();
	Ogre::Vector3 Movement;
	Movement = Vector3(0,0,0);
	mNextMovement = Vector3(0,0,0);
	
	mDirection = mMainNode->getOrientation();

	if(mInput->getKeyboard()->isKeyDown(OIS::KC_W))
	{
		mNextMovement.z = -1; // * mSpeed;
	}
	if(mInput->getKeyboard()->isKeyDown(OIS::KC_S))
	{
		mNextMovement.z = 1; //mSpeed;
	}
	if(mInput->getKeyboard()->isKeyDown(OIS::KC_D))
	{
		mNextMovement.x = 1; //mSpeed;
	}
	if(mInput->getKeyboard()->isKeyDown(OIS::KC_A))
	{
		mNextMovement.x = -1; // * mSpeed;
	}
	if(mInput->getKeyboard()->isKeyDown(OIS::KC_SPACE))
	{
		startJump(mJumpStrength);
	}
	if(mNextMovement.x == 0 && mNextMovement.z == 0)
	{
		accTime = 0;
		//if(mMoveState != ST_IDLE)
		//	mMoveState = ST_WALK_STOPPING;

		//if(mMoveState != ST_WALK_STOPPING)
			mMotion = false;

		mAnimationState = mEntity->getAnimationState( "Idle1" );
		//mAnimationState->setLoop(true);
		mAnimationState->setEnabled(true);		
	}
	else
	{
		//if(mMoveState != ST_WALK_STOPPING && mMoveState != ST_WALK_LOOP	)
		//	mMoveState = ST_WALK_STARTING;
		
		
		//mAccelFactor
		/*
		if(mVel>=1) {
			mVel = 1;
			mMoveState = ST_WALK_LOOP;
			if(mMoveState == ST_WALK_STOPPING)
				mMoveState = ST_IDLE;
		}
		else {
			if(mMoveState == ST_WALK_STOPPING)
				mVel -= 0.1;
			else
				mVel += 0.1;

		}
		*/

		mMotion = true;

		if(!mRotating) {
			mRotating = true;
			mOrientSrc = mPlayerNode->getOrientation();

			Vector3 localY = mPlayerNode->getOrientation() * Vector3::NEGATIVE_UNIT_Z;
			Quaternion quat = localY.getRotationTo(mMainNode->getOrientation() * Vector3::NEGATIVE_UNIT_Z);                        
			mOrientDest = quat;
			
			mDestYaw = Degree(quat.getYaw());
			mYawInc = (mDestYaw < Degree(0)) ? Degree(-mTurnReactionTime) : Degree(mTurnReactionTime) ;
			mYaw = Degree(0);

			mAnimationState = mEntity->getAnimationState( "Walk" );
			mAnimationState->setLoop(true);
			mAnimationState->setEnabled(true);
		}

		if(mCurrentView == CAMERA_THIRD_PERSON_FREE) {
			if(mRotating)
			{
				//This is where i make the character to have a delay turning his body into an arbitrary direction.(see mTurnReactionSpeed)
				mYaw += Degree(mYawInc);
				if( (mYawInc < Degree(0)) ? (mYaw < mDestYaw) : (mYaw > mDestYaw) )
					mRotating = false;
				else
					mPlayerNode->yaw(mYawInc);
			} 
			
		}
	}
	
	NxF32 elapsedTime = mOgre->getTimeSinceLastFrame();
	elapsedTime *= mTimestepMultiplier;
	if(elapsedTime <= 0)
		elapsedTime = 0;

	////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////
	NxVec3 disp = mDefaultGravity; //remover cuando agregue otros estados (nadando, volando, etc)
	if(!mApplyGravity)	
		disp.zero();

	if(mMotion)
	{
		Ogre::Vector3 tmpPos = (mDirection * mNextMovement);
		NxVec3 horizontalDisp = NxTools::convert(tmpPos);
		horizontalDisp.y = 0.0f; //remover cuando agregue otros estados (nadando, volando, etc)
		horizontalDisp.normalize();

		disp += horizontalDisp * mSpeed * mSpeedMultiplier; //gCharacterSpeed
	}
	
	mNbPts = 0;
	NxF32 sharpness = 1.0f;
	NxU32 collisionFlags;
	//NxVec3 d = disp * elapsedTime;
	
	accTime += mOgre->getTimeSinceLastFrame();
	
	NxVec3 d;
	//NxF32 vel = mSpeed + mVel * accTime;
	//if(accTime >= 500)
		d = disp * elapsedTime;
	//else
	//	d = disp * vel;

	NxF32 heightDelta = getHeight(elapsedTime);
	if(heightDelta!=0.0f)
		d.y+=heightDelta;

	NxController* c = mManager->getController(0);
	
	//mAccelFactor = 0.1;
	//mVel = 100;
	//mVel += 0.1;

	c->move(d, 1, 0.000001f, collisionFlags, sharpness);

	if(collisionFlags & NXCC_COLLISION_DOWN) {
		stopJump();
	}

	NxVec3 v = NxVec3(getCharacterPos().x,getCharacterPos().y,getCharacterPos().z);

	//mTestFilter.Apply(v.x,v.y,v.z);
	

	mMainNode->setPosition(NxTools::convert(v));
	v.y = v.y + NxTools::convert(mNodeOffset).y;
	mPlayerNode->setPosition(NxTools::convert(v));

	updateControllers();

	////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////
	//Vector3 dist = PlayerNode->getOrientation() * Vector3::NEGATIVE_UNIT_Z;
	//Quaternion quat = dist.getRotationTo(MainNode->getOrientation() * Vector3::NEGATIVE_UNIT_Z); 
	//mDestYaw = quat.getYaw();
	//mOgre->getDebugText()->addText("yaw =" + Ogre::StringConverter::toString(mDestYaw));
	//mOgre->getDebugText()->addText("yaw =" + Ogre::StringConverter::toString(quat.getYaw()));
	
	const OIS::MouseState &ms = mInput->getMouseStat();
	
	//-----------------------------------------------------------------------------
	//Set mouse displacement
	NxF32 mXRel = (NxF32)(-ms.X.rel);
	NxF32 mYRel = (NxF32)(-ms.Y.rel);
	NxF32 mZRel = (NxF32)(-ms.Z.rel);
	mZoom += Real(mZRel * mMouseSpeed);
	//-----------------------------------------------------------------------------

	//-----------------------------------------------------------------------------
	//Set mouse wheel filter
	if(mUseMouseFilter)
		mZoomFilter.Apply(mZoom);
	//-----------------------------------------------------------------------------

	//-----------------------------------------------------------------------------
	//If the camera hit something between character and camera, snap it
	Vector3 rayDir = mCameraPitchNode->_getDerivedOrientation() * Vector3::UNIT_Z;
	NxVec3 direction = NxVec3(rayDir.x,rayDir.y,rayDir.z);

	NxVec3 cpos = NxVec3(mMainNode->_getDerivedPosition().x,mMainNode->_getDerivedPosition().y,mMainNode->_getDerivedPosition().z);
	NxF32 dist = cameraHit(cpos,direction);

	mCameraPitchNode->setPosition(mCameraPitchNode->getPosition().x,mCameraPitchNode->getPosition().y,mZoom);
	
	if(dist > 0) {
		Real d2 = 0;	
		d2 = mMainNode->_getDerivedPosition().distance(mCameraPitchNode->_getDerivedPosition());
		if(d2 > dist)
			d2 = -(d2 - dist);
		else
			d2 = 0;
		//mOgre->getDebugText()->addText("Dist inc=" + Ogre::StringConverter::toString(d2));
		mCameraPitchNode->translate(0,0,d2);
	}
	//-----------------------------------------------------------------------------

	//-----------------------------------------------------------------------------
	//Filter mouse movement
	if(mUseMouseFilter)
		mFilter.Apply(mXRel,mYRel);
	//-----------------------------------------------------------------------------

	Degree mRotX = Degree(mXRel * mMouseSpeed);
	Degree mRotY = Degree(mYRel * mMouseSpeed);

	mMainNode->yaw(mRotX);
	mCameraNode->pitch(mRotY);

	//-----------------------------------------------------------------------------
	//Blocking yaw and pitch movements...
	Degree viewPitch = Degree(mCameraNode->getOrientation().getPitch());
	if (viewPitch < Degree(-90)) {
		mCameraNode->setOrientation(Quaternion::IDENTITY);
		mCameraNode->pitch(Degree(-90));
	}
	if (viewPitch >  Degree(90)) {
		mCameraNode->setOrientation(Quaternion::IDENTITY);
		mCameraNode->pitch(Degree(90));
	}
	//-----------------------------------------------------------------------------

	//if(mCurrentView == CAMERA_THIRD_PERSON_AIM) {
	//	mPlayerNode->yaw(mRotX);
	//}

	mAnimationState->addTime(time * 1.5);
}
